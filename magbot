#!/usr/bin/env perl
use strict;
use warnings;

use File::Basename;

binmode STDOUT, ":utf8";

=pod

=head1 NAME

magbot - For fetching media from jw.org feeds

=head1 SYNOPSIS

    > magbot

=head1 DESCRIPTION

For use on Android devices via SL4A (see http://code.google.com/p/android-scripting/)
or via command line.

=head1 AUTHOR

Delon Newman <delon.newman@gmail.com>

=cut

#
# Settings
#
my @FORMATS   = qw{ EPUB };
my @LANGUAGES = qw{ E };
my @MAGS      = qw{ w wp g };

my $ROOT_URL = 'http://www.jw.org/index.xjp';
my $APP_NAME = 'MagBot';

my $DIR = {
    audio => "$ENV{HOME}/Podcasts",
    pub   => ["/media/NOOK/My Files/Magazines", "$ENV{HOME}/Reading"]
};

my %FORMATS = (
    MP3  => 'audio',
    M4B  => 'audio',
    EPUB => 'pub',
    PDF  => 'pub'
);
    
# These are for parsing the feeds.  Yes I know it's bad
# to parse XML with regular expressions but I tried to do
# it as clean as I could, _please_ forgive me. ;-)
sub parse_feed {
    local $_     = shift; # content
    my    %feed  = ();

    /<channel>(.*)<\/channel>/gs;
    my $channel = $1;

    /<title>(.*)<\/title>/;
    $feed{title} = $1;

    /<image>\s+<url>(.*)<\/url>/s;
    $feed{image} = $1;

    /<atom:link href="(.*)" rel/s;
    $feed{url} = $1;

    /<description>(.*)<\/description>/;
    $feed{description} = $1;

    (my $pub, $feed{format}) = split ' ', $feed{description};
    $pub =~ /([a-z]+)([A-Z]+)/;
    ($feed{mag}, $feed{lang}) = ($1, $2);

    s/\s+<title>.*<\/itunes:block>//sg;
    $feed{items} = parse_items($_, \%feed);

    \%feed;
}

sub feed_dir {
    my $feed = shift;
    root_dir($feed) . '/' . $feed->{title};
}

sub root_dir {
    my $feed = shift;
    my $type = $FORMATS{$feed->{format}} ||
        die 'cannot find root directory for: ', $feed->{format};

    if ( ref $DIR eq 'HASH' ) {
        if ( ref $DIR->{$type} eq 'ARRAY' ) {
            if ( -e $DIR->{$type}->[0] ) { $DIR->{$type}->[0] }
            else                         { $DIR->{$type}->[1] }
        }
        else { $DIR->{$type} }
    }
    else { $DIR }
}

sub parse_items {
    my ($content, $feed) = @_;

    if ( $content ) {
       my @items = 
            map   { parse_item($_, $feed) }
            grep  { !/^\n\n\s+/ }
            map   { s/^\s+<item>\s+//; $_ }
            split /<\/item>/, $content;

        wantarray ? @items : \@items;
    }
    else {
        wantarray ? () : [];
    }
}

sub parse_item {
    local $_   = shift; # content
    my $feed   = shift;
    my %tokens = (
        title   => 'title',
        link    => 'link',
        pubDate => 'date'
    );

    my %item = (feed => $feed);

    for my $token (keys %tokens) {
        /<$token>(.*)<\/$token>/s;
        $item{$tokens{$token}} = $1;
    }

    \%item;
}

sub issue_dir {
    my ($item, $feed_dir) = @_;
    $feed_dir . '/' . $item->{date};
}

sub item_dir {
    my ($item) = @_;
    my $issue_dir = issue_dir($item, feed_dir($item->{feed}));
    $issue_dir . '/' . item_file($item);
}

sub item_file  {
    my ($item) = @_;

    # TODO: remove this
    $item->{file} //= basename $item->{link} if $item->{link};

    $item->{file};
}


#
# Some monkey business for cross-platformability
#
BEGIN {
    #
    # Try loading Android (from SL4A) and Gtk2::Notify, then create 
    # notify function which sends a notification message on Android
    # or GNOME or prints to STDOUT anywhere else
    #
    my $droid;
    eval {
        require Android;
        Android->import;
        $droid //= Android->new;
    };

    my $gtk;
    eval {
        require Gtk2::Notify;
        Gtk2::Notify->import(-init, basename $0);
        $gtk = 1;  
    };

    use Sys::Syslog qw{ :standard };

    sub notify {
        if    ( $droid ) { $droid->notify($APP_NAME, @_) }
        elsif ( $gtk   ) {
            Gtk2::Notify->new($APP_NAME . ' says:', join('', @_))->show;
            print @_, "\n";
        }
        else { print @_, "\n" }

        # syslog
        openlog $APP_NAME, 'ndelay,pid', 'local0';
        syslog 'info', @_;
        closelog;
        1;
    }

    #
    # Try loading LWP::Simple, otherwise use HTTP::Tiny
    # to create work alikes for 'get' and 'getstore'
    #
    eval {
        require LWP::Simple;
        LWP::Simple->import;
    };
    if ( $@ ) {
        require HTTP::Tiny;
        HTTP::Tiny->import;
    
        no strict 'subs';
        
        *get = sub { HTTP::Tiny->new->get(@_)->{content} };
    
        *getstore = sub {
            my $url  = shift;
            my $file = shift;
        
            my $content = get $url;
            open FILE, '>', $file or die "cannot open $file";
            print FILE $file;
            close FILE;
        };
    
        use strict 'subs';
    }
}

use Data::Dump qw(dump);

#
# Top-Level Functions
#
sub download_feeds { map { get $_ } @_ }

sub find_new {
    map  {  $_->[1] }
    grep { !$_->[0] }
    map  { map { [ -e item_dir($_), $_ ]  } @{$_->{items}} } @_;
}

sub download_media {
    my @urls = @_;

    notify "Downloading feeds and checking for new items...";

    my @items = find_new map { parse_feed($_) } download_feeds @urls;
    if ( int(@items) == 0 ) {
        notify "There's nothing new in your feeds.";
        exit;
    }

    notify "Downloading ", int(@items), " items...\n";
    
    for my $item (@items) {
        my $root_dir = root_dir $item->{feed};
        mkdir $root_dir unless -e $root_dir;

        my $feed_dir = feed_dir $item->{feed};
        mkdir $feed_dir unless -e $feed_dir;

        my $issue_dir = issue_dir $item, $feed_dir;
        mkdir $issue_dir unless -e $issue_dir;

        my $path = item_dir $item;
        if ( -e $path ) {
            print "  '", $item->{title}, "' exists at\n   --> '", $path, "'\n\n";
        } elsif ( !$item->{link} ) {
            next;
        } else {
            print "  downloading '", $item->{title}, "' to \n  --> ", $path, "\n";

            getstore $item->{link}, $path unless -e $path;
            print "  ok.\n\n";
        }
    }
    
    notify "Okay the work is complete! ;-)";
}

# for readability, toOO many nested maps
sub apply {
    my ($fn, @list) = @_;
    map { $fn->($_) } @list;
}

# partially applied function to da FACE!!
sub gen_urls {
    my ($format) = @_;

    my %types = (
        audio => 'sFFZRQVNZNT',
        pub   => 'sFFCsVrGZNT'
    );
    
    my $type = $FORMATS{$format};

    sub {
        my ($mag) = @_;
        sub {
            my ($lang) = @_;
            "$ROOT_URL?option=$types{$type}&rln=$lang&rmn=$mag&rfm=$format";
        }
    }
}

# Now to the main event!!
if ( __FILE__ eq $0 ) {
    my @urls =
        map { apply $_, @LANGUAGES }
        map { apply $_, @MAGS }
        map { gen_urls $_ } @FORMATS;

    download_media @urls;
}
