#!/usr/bin/env perl
use v5.10;
use strict;
use warnings;

binmode STDOUT, ':utf8';

=head1 NAME

magbot - For fetching media from jw.org feeds

=head1 SYNOPSIS

    > magbot
    # downloads magazines as specified in the $HOME/.magbot configuration file

    > magbot -d
    # starts in daemon mode and checks for new downloads each day

    > magbot -c
    # checks for new items in feeds in the $HOME/.magbot configuration file reports
    # the results on the screen and exits

    > magbot -c g E MP3
    # checks the current English Awake! feed and exits

    > magbot g E MP3
    # downloads the current English Awake! magazines in MP3 format

    > magbot w J PDF
    # downloads the current Japanese Watchtower magazines in PDF format

=head1 DESCRIPTION

For fetching media from jw.org from the command-line prints
Gtk notifications, to standard output, and to Syslog.

=head1 DEPENDENCIES

    YAML
    XML::LibXML
    Gtk2::Notify (optional)
    HTTP::Tiny

=head1 AUTHOR

Delon Newman <delon.newman@gmail.com>

=cut

use YAML;
use HTTP::Tiny;
use XML::LibXML;
use Getopt::Long;
use Data::Dump qw{ dump };
use Sys::Syslog qw{ :standard };

use File::Spec;
use File::Basename;

use AnyEvent;
use AnyEvent::HTTP;

use constant CONFIG_FILE => "$ENV{HOME}/.magbot";
use constant DEFAULTS => {
    mags => {
        w  => { E => [qw{ EPUB M4B }] },
        wp => { E => [qw{ EPUB M4B }] },
        g  => { E => [qw{ EPUB M4B }] }
    },
    dir => {
        audio  => "$ENV{HOME}/Podcasts",
        pub    => "$ENV{HOME}/Reading"
    }
};


#
# Settings
#

my $VERSION   = '0.6.1';
my $APP_NAME  = 'MagBot';
my $ROOT_URL  = 'http://www.jw.org/index.xjp';
my $FILE_URL  = 'http://download.jw.org/files/media_magazines';
my $MAGS      = config_or_defaults('mags');
my $DIR       = config_or_defaults('dir');

# Valid mags, languages, formats
my %MAGS = (
    g  => 'Awake!',
    w  => 'Watchtower',
    wp => 'Watchtower (Public Edition)'
);

my %MAGS_DAYS = (
    g  => '',
    w  => '15',
    wp => '01',
);

# map valid formats to basic 'type'
my %FORMATS = (
    MP3  => 'audio',
    M4B  => 'audio',
    AAC  => 'audio',
    EPUB => 'pub',
    PDF  => 'pub'
);

my %FORMATS_EXTENSIONS = (
    MP3  => 'mp3.zip',
    M4B  => 'm4b',
    AAC  => 'm4b',
    EPUB => 'epub',
    PDF  => 'pdf'
);

my %LANGUAGES = (
    AP  => "Aymara", 
    B   => "ÄeÅ¡tina", 
    D   => "Dansk", 
    X   => "Deutsch", 
    ST  => "eesti", 
    E   => "English", 
    S   => "espaÃ±ol", 
    F   => "FranÃ§ais", 
    C   => "hrvatski", 
    YW  => "Ikinyarwanda", 
    IN  => "Indonesia", 
    I   => "italiano", 
    SW  => "Kiswahili", 
    LT  => "LatvieÅ¡u", 
    L   => "lietuviÅ³", 
    H   => "magyar", 
    MG  => "Malagasy", 
    MT  => "Malti", 
    O   => "Nederlands", 
    N   => "Norsk", 
    PA  => "Papiamentu (KÃ²rsou)", 
    P   => "polski", 
    T   => "PortuguÃªs", 
    QUB => "Quechua (Bolivia)", 
    M   => "RomÃ¢nÄ", 
    AL  => "shqip", 
    V   => "slovenÄina", 
    SV  => "slovenÅ¡Äina", 
    FI  => "Suomi", 
    Z   => "Svenska", 
    TK  => "TÃ¼rkÃ§e", 
    G   => "ÎÎ»Î»Î·Î½Î¹ÎºÎ®", 
    BL  => "Ð±ÑÐ»Ð³Ð°ÑÑÐºÐ¸", 
    U   => "ÑÑÑÑÐºÐ¸Ð¹", 
    SB  => "ÑÑÐ¿ÑÐºÐ¸", 
    K   => "ÑÐºÑÐ°ÑÐ½ÑÑÐºÐ°", 
    GE  => "á¥áá áá£áá", 
    REA => "ÕÕ¡ÕµÕ¥ÖÕ¥Õ¶", 
    TL  => "à®¤à®®à®¿à®´à¯", 
    MY  => "à´®à´²à´¯à´¾à´³à´", 
    SI  => "à¹à¸à¸¢", 
    J   => "æ¥æ¬èª", 
    CHS => "æ±è¯­ç®åå­", 
    CH  => "æ¼¢èªç¹é«å­", 
    KO  => "íêµ­ì´", 
);


BEGIN {
    #
    # Print messages with Gtk2::Notify, to syslog, and to STDOUT
    # any of which are available.
    #
    my $gtk;
    eval {
        require Gtk2::Notify;
        Gtk2::Notify->import(-init, basename $0);
        $gtk = 1;  
    };

    sub notify {
        if ( $gtk ) {
            Gtk2::Notify->new($APP_NAME . ' says:', join('', @_))->show;
        }

        # syslog
        openlog $APP_NAME, 'ndelay,pid', 'local0';
        syslog 'info', @_;
        closelog;

        print @_, "\n"
    }


    #
    # Error Reporting
    #

    sub notify_fatal {
        if ( $gtk ) {
            Gtk2::Notify->new($APP_NAME . ' says:', join('', @_))->show;
        }

        # syslog
        openlog $APP_NAME, 'ndelay,pid', 'local0';
        syslog 'ERR', @_;
        closelog;

        print STDERR @_, "\n";
        exit 1;
    }
}


#
# Functions for accessing configuration
#

# read from configuration file or from defaults
sub config_or_defaults {
    if ( wantarray ) {
        my $ref = config(@_) || defaults(@_);
        if ( ref $ref eq 'HASH' || ref $ref eq 'ARRAY' ) { @{$ref} }
        else                                             {  ($ref) }
    }
    else {
        config(@_) || defaults(@_);
    }
}

# read from configuration file
{
    my $config;
    sub config {
        $config //= do {
            my $f = CONFIG_FILE;
            if ( -e $f && (my $yaml = YAML::LoadFile($f)) ) { $yaml }
            else {
                open my $fh, '>', $f or die "can't write to $f";
                print $fh YAML::Dump(DEFAULTS);
                close $fh;
                YAML::LoadFile($f);
            }
        };
    
        if ( wantarray ) { @{read_config($config, @_)} }
        else             {   read_config($config, @_) }
    }
}

# read from defaults
sub defaults { 
    if ( wantarray ) { @{read_config(DEFAULTS, @_)} }
    else             {   read_config(DEFAULTS, @_)  }
}

# read from configuration data structure
sub read_config {
    my ($config, @attrs) = @_;

    if ( @attrs == 1 ) {
        my $ref = $config->{$attrs[0]};
        if ( wantarray ) {
            if    ( ref $ref eq 'HASH' )  { %{$ref} }
            elsif ( ref $ref eq 'ARRAY' ) { @{$ref} }
            else                          {  ($ref) }
        }
        else {
            $ref
        }
    }
    else {
        read_config($config->{shift @attrs}, @attrs);
    }
}


#
# Some monkey business for IO
#

# TODO: Use AnyEvent::HTTP to get and store from HTTP asyncronosly.
# see: https://metacpan.org/module/AnyEvent::HTTP#HTTP-1.1-FILE-DOWNLOAD

# get content from HTTP
sub get {
    my $res = eval { HTTP::Tiny->new->get(@_) };

    if ( $@ ) {
        say "Can't fetch '", @_, '\' ', $@;
        notify_fatal "Can't download feed, exiting.";
    }

    if ( $res->{content} =~ qr{File not found.} ) {
        notify_fatal "When fetching ", @_, ":\n  ", $res->{content};
    }
    else {
        $res->{content};
    }
}

# get and store content from HTTP to a file
sub getstore {
    my ($url, $file) = @_;

    my $content = get($url); # allows to die before writing file
    open my $fh, '>', $file or die "can't write to $file";
    print $fh $content;
}

#
# For parsing feeds
#
# trys to always returns as much of a workable data structure as possible
#
#   $feed = {
#       title       => '',
#       description => '',
#       language    => '',
#       url         => '',
#       image       => '',
#       items       => [
#           {
#               title => '',
#               link  => '',
#               date  => '',
#               feed  => \$feed,
#           },
#           ...
#       ]
#   }
#
sub parse_feed {
    my ($xml) = @_; # content
    my %feed  = ();

    my $dom  = XML::LibXML->load_xml(string => $xml);
    my $chan = $dom->getElementsByTagName('channel')->get_node(0);
    
    sub child {
        my ($parent, %args) = @_;
        

        my @tags  = @{$args{tags}} if $args{tags};
        my $tag   = $args{tag} // shift @tags;
        my $nodes = $parent->getChildrenByTagName($tag);

        if ( $nodes->size > 1 ) {
            my @elems = $nodes->get_nodelist;
            wantarray ? @elems : \@elems;
        }
        elsif ( $nodes->size == 1 ) {
            my $elem = $nodes->get_node(0);

            if    ( $args{attr} ) { $elem->getAttribute($args{attr}) }
            elsif ( !@tags )      { $elem->textContent }
            else                  { child($elem, tags => \@tags) }
        }
        else {
            undef;
        }
    }

    sub items {
        my ($feed, @elems) = @_;

        return undef if (@elems == 1 && grep !defined $_, @elems); 

        my @items = map {
          { title => child($_, tag => 'title'),
            link  => child($_, tag => 'link'),
            date  => child($_, tag => 'pubDate'),
            feed  => $feed }
        } @elems;

        \@items;
    }
    
    $feed{title}       = child $chan, tag  => 'title';
    $feed{description} = child $chan, tag  => 'description';
    $feed{language}    = child $chan, tag  => 'language';
    $feed{image}       = child $chan, tags => ['image', 'url'];
    $feed{url}         = child $chan, tag  => 'atom:link', attr => 'href';
    $feed{items}       = items(\%feed, child($chan, tag => 'item'));

    (my $pub, $feed{format}) = split ' ', $feed{description};
    $pub =~ /([a-z]+)([A-Z]+)/;
    ($feed{mag}, $feed{lang}) = ($1, $2);

    \%feed;
}

#
# Some functions for accessing directory structure
#

sub feed_dir {
    my $feed = shift;

    $feed->{dir} //= root_dir($feed) . '/' . $feed->{title};

    $feed->{dir};
}

sub root_dir {
    my $type = do {
        my $arg = shift;
        if ( $arg && ref $arg && $arg->{format} ) {
            $FORMATS{$arg->{format}} //
                die 'cannot find root directory for: ', $arg->{format};
        }
        else { $arg }
    };

    if ( ref $DIR eq 'HASH' ) {
        if ( ref $DIR->{$type} eq 'ARRAY' ) {
            if ( -e $DIR->{$type}->[0] ) { $DIR->{$type}->[0] }
            else                         { $DIR->{$type}->[1] }
        }
        else { $DIR->{$type} }
    }
    else { $DIR }
}

sub issue_dir {
    my ($item, $feed_dir) = @_;
    $feed_dir . '/' . $item->{date};
}

sub item_dir {
    my ($item) = @_;
    my $issue_dir = issue_dir $item, feed_dir($item->{feed});

    $item->{dir} //= $issue_dir . '/' . item_file($item);

    $item->{dir}
}

sub item_file  {
    my ($item) = @_;

    $item->{file} //= basename $item->{link} if $item->{link};

    $item->{file};
}

#
# Top-Level Functions
#

sub download_feeds { map { get $_ } @_ }

sub find_new {
    map  {  $_->[1] }
    grep { !$_->[0] }
    map  { map { [ -e item_dir($_), $_ ]  } @{$_->{items}} } @_;
}

sub has_items {
    my ($feed) = @_;

    if ( $feed->{items} ) { 1 }
    else {
        notify "No items found for ", $feed->{title};
        0;
    }
}

sub get_new_items {
    my @urls  = @_;
    my @items = find_new grep has_items($_), map parse_feed($_), download_feeds @urls;

    wantarray ? @items : \@items;
}

sub download_media {
    my @urls  = @_;
    my @items = get_new_items @urls;

    notify_fatal "There's nothing new in your feeds." if @items == 0;

    notify "Downloading ", int(@items), " items...\n";
    
    for my $item (@items) {
        my $root_dir = root_dir $item->{feed};
        mkdir $root_dir unless -e $root_dir;

        my $feed_dir = feed_dir $item->{feed};
        mkdir $feed_dir unless -e $feed_dir;

        my $issue_dir = issue_dir $item, $feed_dir;
        mkdir $issue_dir unless -e $issue_dir;

        my $path = item_dir $item;
        if ( $item->{link} ) {
            print "  downloading '", $item->{title}, "' to \n  --> ", $path, "\n";

            getstore($item->{link}, $path) unless -e $path;
            print "  ok.\n\n";
        }
    }
    
    notify "Okay the work is complete! ;-)";
}

# Yaay!! Gen them URLs
sub gen_urls {
    my ($mags) = @_;
    magmap($mags => sub {
        my ($mag, $lang, $format) = @_;

        my %types = (
            audio => 'sFFZRQVNZNT',
            pub   => 'sFFCsVrGZNT'
        );

        my $type = $FORMATS{$format};

        "$ROOT_URL?option=$types{$type}&rln=$lang&rmn=$mag&rfm=$format";
    });
}

sub parse_date {
    local ($_) = @_;

    # pad month with zero
    my $m = sub {
        local ($_) = @_;
        if ( /\d{2,2}/ ) {   $_  }
        else             { "0$_" }
    };

    # YYYY-MM
    if    ( /(\d\d\d\d)-(\d{1,2})/  ) { ($1, $m->($2)) }

    # MM/YYYY
    elsif ( /(\d{1,2})\/(\d\d\d\d)/ ) { ($2, $m->($1)) }

    # MM
    elsif ( /(\d{1,2})/             ) {
        my ($s, $min, $h, $d, $mon, $year) = localtime;
        ($year + 1900, $m->($1))
    }
    else { @_ }
}

sub gen_file_url {
    my ($mag, $lang, $format, $date) = @_;

    my $ext = $FORMATS_EXTENSIONS{$format} //
        notify_fatal "'$format' is not a valid format";

    my ($year, $month) = parse_date($date);

    "$FILE_URL/${mag}_${lang}_${year}${month}$MAGS_DAYS{$mag}.$ext";
}


# a higer order function for creating lists composed of
# magazine components ($mag, $language, and $format)
# from magazine data structures
sub magmap {
    my ($mags, $fn) = @_;
    my @mags = keys %$mags;
    
    map {
        my $mag   = $_;
        my @langs = keys %{$mags->{$mag}};

        map {
            my $lang    = $_;
            my @formats = @{$mags->{$mag}->{$lang}};
            
            map {
                my $format = $_;
                $fn->($mag, $lang, $format);
            } @formats

        } @langs

    } @mags
}

# convert args '($mag, $lang, $format)' into valid
# mag data structure that eval_mags expects, namely:
# '{ $mag => { $lang => [ $formats ] }'
sub mag_from_args {
    my ($mag, $lang, $format) = @_;

    my @formats = keys %FORMATS;
    my @langs   = keys %LANGUAGES;
    my @mags    = keys %MAGS;

    if ( @_ < 3 ) {
        undef;
    }
    else {
        notify_fatal "'$mag' is an invalid magazine"  unless grep $_ eq $mag, @mags;
        notify_fatal "'$lang' is an invalid language" unless grep $_ eq $lang, @langs;
        notify_fatal "'$format' is an invalid format" unless grep $_ eq $format, @formats;

        return { $mag => { $lang => [ $format ] } };
    }
}

sub get_mags {
    my @args = @_;

    if ( @args ) {
        if ( !(my $mag = mag_from_args(@args)) ) {
            notify_fatal "Need to specify magazine, language, and format to download.";
        }
        else { $mag }
    }
    else { $MAGS }
}

sub report_mags {
    my ($mags) = @_;

    join "\n", magmap($mags => sub {
        my ($m, $l, $f) = @_;
        "  $LANGUAGES{$l} $MAGS{$m} in $f format";
    });
}

sub daemonize_or_run($$) {
    my ($cond, $fn) = @_;

    if ( $cond ) {
        my $int = config_or_defaults('check-interval');
        AE::timer 0, $int => sub {
            $fn->();
        };
    }
    else { $fn->() }
}

#
# Commands
#

# And now the main event!!
sub main {
    my ($daemonize, @args) = @_;

    daemonize_or_run $daemonize => sub {
        if ( @args < 4 ) {
            my $mags = get_mags(@args);
            my $rpt  = report_mags($mags);

            notify "Checking for new items and downloading:\n", $rpt, "\n";
            download_media gen_urls($mags);
        }
        else {
            my $url  = gen_file_url(@args);
            my $dir  = root_dir($FORMATS{$args[2]}); # second arg specifies format  
            my $rpt  = report_mags(mag_from_args(@args));
            my $path = File::Spec->join($dir, basename $url);

            if ( -e $path ) { notify "$path already exists." }
            else {
                notify "Downloading:\n", $rpt,
                       "\n    from: ", $url,
                       "\n    to: ", $path, "\n";

                getstore($url => $path);
                notify "download complete :-)";
            }
        }
    };

    exit 0;
}

sub check {
    my ($daemonize, @args) = @_;
    my $mags = get_mags(@args);
    my $rpt  = report_mags($mags);

    notify "Checking for new items:\n", $rpt, "\n";

    daemonize_or_run $daemonize => sub {
        my @items = get_new_items(gen_urls $mags);
        if ( @items ) {
            notify "New items:\n", join "\n", map { "  " . $_->{title} } @items;
            exit 0;
        }
        else {
            notify 'No new items found.';
            exit 1;
        }
    };
}

sub help {
    print <<HELP;
$APP_NAME $VERSION

Usage: $0 [OPTIONS] [MAG CODE] [LANGUAGE CODE] [FORMAT]

  Options:
    --check, -c
        check for new feed items as sepecified by arguments
        or if none are present by configuration in
        $ENV{HOME}/.magbot, report and exit

    --daemonize, -d
        run as a backgroud process daily

    --help, -h
        display this message

  Other arguments
    MAG CODE:
        Used to indicate which magazine to download valid
        values are 'w' (Watchtower), 'g' (Awake!), and 'wp'
        (Watchtower - Public Edition).

    LANGUAGE CODE:
        Used to indicate which language edition of the
        specified magazine should be downloaded.

    FORMAT:
        Used to indicate which file format to download the
        magazine in.  Valid values are 'MP3', 'M4B', 'AAC',
        'EPUB', and 'PDF'.
HELP

    exit 0;
}


if ( __FILE__ eq $0 ) {
    my $daemonize = 0;

    GetOptions(
        'daemonize|d' => sub { $daemonize = 1 }, # run daily
        'help|h'      => sub { help() },
        'check|c'     => sub { check($daemonize, @ARGV) }
    );

    main($daemonize, @ARGV);
}

1;
