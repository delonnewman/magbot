#!/usr/bin/env perl
use v5.10;
use strict;
use warnings;

use YAML;
use HTTP::Tiny;
use XML::LibXML;
use Sys::Syslog qw{ :standard };
use File::Basename;
use Data::Dump qw{ dump };

binmode STDOUT, ':utf8';

=pod

=head1 NAME

magbot - For fetching media from jw.org feeds

=head1 SYNOPSIS

    > magbot

=head1 DESCRIPTION

For fetching media from jw.org from the command-line prints
Gtk notifications, to standard output, and to Syslog.

=head1 DEPENDENCIES

    YAML
    XML::LibXML
    Gtk2::Notify (optional)
    HTTP::Tiny

=head1 AUTHOR

Delon Newman <delon.newman@gmail.com>

=cut

#
# Settings
#

my $APP_NAME  = 'MagBot';
my $ROOT_URL  = 'http://www.jw.org/index.xjp';

my @FORMATS   = config_or_defaults('formats');
my @LANGUAGES = config_or_defaults('languages');
my @MAGS      = config_or_defaults('mags');

my $DIR = {
    audio => config_or_defaults(dir => 'audio'),
    pub   => config_or_defaults(dir => 'pub')
};

my %FORMATS = (
    MP3  => 'audio',
    M4B  => 'audio',
    EPUB => 'pub',
    PDF  => 'pub'
);

BEGIN {
    #
    # Constants
    #
    sub CONFIG_FILE () { "$ENV{HOME}/.magbot" }

    # default configuration
    sub DEFAULTS () {
        {
            formats   => [qw{ EPUB }],
            languages => [qw{ E }],
            mags      => [qw{ w wp g }],
            dir       => {
                audio  => "$ENV{HOME}/Podcasts",
                pub    => "$ENV{HOME}/Reading"
            }
        };
    }

    #
    # Print messages with Gtk2::Notify, to syslog, and to STDOUT
    # any of which are available.
    #
    my $gtk;
    eval {
        require Gtk2::Notify;
        Gtk2::Notify->import(-init, basename $0);
        $gtk = 1;  
    };

    sub notify {
        if ( $gtk ) {
            Gtk2::Notify->new($APP_NAME . ' says:', join('', @_))->show;
        }

        # syslog
        openlog $APP_NAME, 'ndelay,pid', 'local0';
        syslog 'info', @_;
        closelog;

        print @_, "\n"
    }
}


#
# Functions for accessing configuration
#

# read from configuration file or from defaults
sub config_or_defaults {
    if ( wantarray ) {
        my $ref = config(@_) || defaults(@_);
        if ( ref $ref eq 'HASH' || ref $ref eq 'ARRAY' ) { @{$ref} }
        else                                             {   $ref  }
    }
    else {
        config(@_) || defaults(@_);
    }
}

# read from configuration file
{
    my $config;
    sub config {
        $config //= do {
            my $f = CONFIG_FILE;
            if ( -e $f && (my $yaml = YAML::LoadFile($f)) ) { $yaml }
            else {
                open my $fh, '>', $f or die "can't write to $f";
                print $fh YAML::Dump(DEFAULTS);
                close $fh;
                YAML::LoadFile($f);
            }
        };
    
        if ( wantarray ) { @{read_config($config, @_)} }
        else             {   read_config($config, @_) }
    }
}

# read from defaults
sub defaults { 
    if ( wantarray ) { @{read_config(DEFAULTS, @_)} }
    else             {   read_config(DEFAULTS, @_)  }
}

# read from configuration data structure
sub read_config {
    my ($config, @attrs) = @_;

    if ( @attrs == 1 ) {
        my $ref = $config->{$attrs[0]};
        if ( wantarray ) {
            if    ( ref $ref eq 'HASH' )  { %{$ref} }
            elsif ( ref $ref eq 'ARRAY' ) { @{$ref} }
            else                          { ($ref) }
        }
        else {
            $ref
        }
    }
    else {
        read_config($config->{shift @attrs}, @attrs);
    }
}
    

#
# Some monkey business for IO
#

# get content from HTTP
sub get {
    my $res;

    eval {
        $res = HTTP::Tiny->new->get(@_);
    };

    if ( $0 ) {
        say "Error fetching ", @_, ': ', $@;
        exit 0;
    }

    $res->{content};
}
    
# get and store content from HTTP to a file
sub getstore {
    my $url  = shift;
    my $file = shift;

    my $content = get $url;
    open FILE, '>', $file or die "cannot open $file";
    print FILE $file;
    close FILE;
}

#
# For parsing feeds
#
sub parse_feed {
    local $_ = shift; # content
    my %feed = ();

    my $dom  = XML::LibXML->load_xml(string => $_);
    my $chan = $dom->getElementsByTagName('channel')->get_node(0);

    sub child {
        my ($parent, %args) = @_;

        my @tags  = @{$args{tags}} if $args{tags};
        my $tag   = $args{tag} // shift @tags;
        my $nodes = $parent->getChildrenByTagName($tag);

        if ( $nodes->size > 1 ) {
            my @elems = $nodes->get_nodelist;
            wantarray ? @elems : \@elems;
        } else {
            my $elem  = $nodes->get_node(0);

            if    ( $args{attr} ) { $elem->getAttribute($args{attr}) }
            elsif ( !@tags )      { $elem->textContent }
            else                  { child($elem, tags => \@tags) }
        }
    }

    sub items {
        my ($feed, @elems) = @_;

        my @items = map {
          { title => child($_, tag => 'title'),
            link  => child($_, tag => 'link'),
            date  => child($_, tag => 'pubDate'),
            feed  => $feed }
        } @elems;

        \@items;
    }
    
    $feed{title}       = child $chan, tag  => 'title';
    $feed{description} = child $chan, tag  => 'description';
    $feed{language}    = child $chan, tag  => 'language';
    $feed{image}       = child $chan, tags => ['image', 'url'];
    $feed{url}         = child $chan, tag  => 'atom:link', attr => 'href';
    $feed{items}       = items(\%feed, child($chan, tag => 'item'));

    (my $pub, $feed{format}) = split ' ', $feed{description};
    $pub =~ /([a-z]+)([A-Z]+)/;
    ($feed{mag}, $feed{lang}) = ($1, $2);

    \%feed;
}

#
# Some functions for accessing directory structure
#

sub feed_dir {
    my $feed = shift;

    $feed->{dir} //= root_dir($feed) . '/' . $feed->{title};

    $feed->{dir};
}

sub root_dir {
    my $feed = shift;
    my $type = $FORMATS{$feed->{format}} ||
        die 'cannot find root directory for: ', $feed->{format};

    if ( ref $DIR eq 'HASH' ) {
        if ( ref $DIR->{$type} eq 'ARRAY' ) {
            if ( -e $DIR->{$type}->[0] ) { $DIR->{$type}->[0] }
            else                         { $DIR->{$type}->[1] }
        }
        else { $DIR->{$type} }
    }
    else { $DIR }
}

sub issue_dir {
    my ($item, $feed_dir) = @_;
    $feed_dir . '/' . $item->{date};
}

sub item_dir {
    my ($item) = @_;
    my $issue_dir = issue_dir $item, feed_dir($item->{feed});

    $item->{dir} //= $issue_dir . '/' . item_file($item);

    $item->{dir}
}

sub item_file  {
    my ($item) = @_;

    $item->{file} //= basename $item->{link} if $item->{link};

    $item->{file};
}

#
# Top-Level Functions
#

sub download_feeds { map { get $_ } @_ }

sub find_new {
    map  {  $_->[1] }
    grep { !$_->[0] }
    map  { map { [ -e item_dir($_), $_ ]  } @{$_->{items}} } @_;
}

sub download_media {
    my @urls = @_;

    notify "Downloading feeds and checking for new items...";

    my @items = find_new map { parse_feed $_ } download_feeds @urls;
    if ( int(@items) == 0 ) {
        notify "There's nothing new in your feeds.";
        exit;
    }

    notify "Downloading ", int(@items), " items...\n";
    
    for my $item (@items) {
        my $root_dir = root_dir $item->{feed};
        mkdir $root_dir unless -e $root_dir;

        my $feed_dir = feed_dir $item->{feed};
        mkdir $feed_dir unless -e $feed_dir;

        my $issue_dir = issue_dir $item, $feed_dir;
        mkdir $issue_dir unless -e $issue_dir;

        my $path = item_dir $item;
        if ( -e $path ) {
            print "  '", $item->{title}, "' exists at\n   --> '", $path, "'\n\n";
        } elsif ( !$item->{link} ) {
            next;
        } else {
            print "  downloading '", $item->{title}, "' to \n  --> ", $path, "\n";

            getstore $item->{link}, $path unless -e $path;
            print "  ok.\n\n";
        }
    }
    
    notify "Okay the work is complete! ;-)";
}

# applies codref to list entries; for readability, toOO many nested maps
sub apply {
    my ($fn, @list) = @_;
    map { $fn->($_) } @list;
}

# partially applied function to da FACE!!
sub gen_urls {
    my ($format) = @_;

    my %types = (
        audio => 'sFFZRQVNZNT',
        pub   => 'sFFCsVrGZNT'
    );
    
    my $type = $FORMATS{$format};

    sub {
        my ($mag) = @_;
        sub {
            my ($lang) = @_;
            "$ROOT_URL?option=$types{$type}&rln=$lang&rmn=$mag&rfm=$format";
        }
    }
}

# Now to the main event!!
if ( __FILE__ eq $0 ) {
    my @urls =
        map { apply $_, @LANGUAGES }
        map { apply $_, @MAGS }
        map { gen_urls $_ } @FORMATS;

    download_media @urls;
}
